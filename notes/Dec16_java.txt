Plan for the day
--------------------
Collections	- Map	we will learn this now
String
Exception


Map
-------
key - value pair

ex:
	1 - India
	2 - Australia	
	3 - Japan



ex:
	121	Raja
	122	Abdul
	123	Suresh


List
Set
	these are collections

Map is not a collection but, an application of collections

Map classes:
------------------
HashMap
TreeMap
LinkedHashMap


Entry
	key
	value

HashMap<Integer, String> countryMap=new HashMap<>();


methods of Map:
----------------------
	put		adds an entry to the map	put(1,"India");
	get		gets the value based on key	get(1);			//returns "India"

			get(-1)		returns null		because, the key is not found in the map





import java.util.HashMap;
import java.util.Map.Entry;

public class Main {

	public static void main(String[] args) {
		HashMap<Integer, String> countryMap=new HashMap<>();
		countryMap.put(1,"India");
		countryMap.put(2,"Australia");
		countryMap.put(3,"Japan");
		countryMap.put(4,"China");
		countryMap.put(5,"Sri lanka");
		countryMap.put(6,"Germany");
		countryMap.put(7,"France");
		countryMap.put(8,"England");
		countryMap.put(9,"Argentina");
		countryMap.put(10,"Brazil");
		
		//added 10 entries into the map
		
		//how to display all the entries
		//1) using for each loop
		
		for(Entry<Integer, String> entry:countryMap.entrySet())
		{
			System.out.println(entry.getKey()+"\t"+entry.getValue());
		}
	}

}



///////
//		2) using keys
		Set<Integer> keys = countryMap.keySet();
//		System.out.println(keys);
		for(Integer key:keys)
		{
			System.out.println(key+"\t"+countryMap.get(key));
		}

Points to remember about Maps:
-------------------------------------------
key value  pair

Key
	is a Set	(means, no duplicates)
	can we assign null for a key????????
		yes. But only 1 null. why?	
			because, another null is considered as duplicate

	Ok, if i put a duplicate key, what happens?




if the key was found, then update it.


Key is a Set
	which set?
		HashSet????	or	TreeSet????		or LinkedHashSet????
	It is based on which Map it is?
		If the map is 
			HashMap, then the key is a HashSet
			TreeMap, then the key is a TreeSet
			LinkedHashMap, then the key is LinkedHashSet





put 
	is used to add a new entry
	is used to update an existing entry

	put(1,"India");		// 1 is not found yet, so it is added as a new entry
	put(1,"Bharath");		// 1 is already found in the keys, so it is updating the value



get
	accepts the key as argument
		returns the value
	if the key is not found, 
		returns null



	static Map<String,Integer> calculateLocationCount(List<College> list)
	{
		Map<String,Integer> result=new TreeMap<>();
		//loop the list of colleges and check their location
		for(College college:list)
		{
			String location=college.getLocation();
			//check if that location is already found in the map
			Integer count = result.get(location);
			if(count==null)
			{
				count=0;
			}
			count++;		
			
			result.put(location, count);
		}
		
		return result;		
	}

--------------------
Task:
	Mock 29 Req #6	solve this using map




<Date,Integer>


Activity:
1) Identify all the methods of 
	ArrayList
	LinkedList
	HashSet			order is based on hashCode
	TreeSet			comparator/comparable
	LinkedHashSet		order is same as the elements added

	String
	StringBuilder
	StringBuffer


Requirement:
public class DistinctTask
{
	public static ArrayList<Integer> findDistinct(ArrayList<Integer> input)
	{
		//return only the DISTINCT elements present in the input
		//code here
		HashSet<Integer> temp=new HashSet<>(input);
		ArrayList<Integer> result=new ArrayList<>(temp);
		return result;		//incomplete
	}

	public static void main(String args[])
	{
		ArrayList<Integer> source=new ArrayList<>();
		source.add(10);
		source.add(20);
		source.add(10);
		source.add(30);
		source.add(10);
		source.add(40);
		source.add(50);
		source.add(40);
			
		ArrayList<Integer> result=findDistinct(source);	
		//output should be 10, 20, 30, 40, 50
		for(Integer i : result)
			System.out.println(i);
	}
}
ArrayList input


------------------------------------
Exception Handling
--------------------------
Handling of errors
Runtime errors

Errors vs Exceptions

Errors cannot be handled
Error means, terminate the program

Exceptions can be handled
	means, in response to the exception, the program can continue in an alternate path.


What is Exception?
	are defined abnormal events
	every exception in java, is defined as a class
		A class that is derived from Exception (or) RuntimeException (or) any of their sub classes, are called 		exception class

	If a class is derived from Exception class or any of its sub class, then it is a checked exception
	If a class is derived from RuntimeException clalss, or any of its sub class, then it is unchecked exception

What is checked exception?
	compile checks these exceptions
	and the program does not compile unless they
		handle these exceptions (or)		using try-catch-finally blocks
		declare these exceptions		throws clause


Exampe for checked exception:
	IOException
	

throws
	is used to inform the compiler that this method throws these exceptions but does not handle.
	the calling method can handle the exception


Unchecked exception
	are not checked by the compiler
	they can be handled or left unhandled
	they need not be declared using throws


throw
	is used to throw an object of exception class
throws
	is used to declare that the method throws these exceptions and does not handle them but calling method to handle

try
catch
finally

try block
	is called as guarded section
	exceptions occurred in this block can be handled by 1 or more catch blocks

catch block
	is executed when exception occurred
	there can be many catch blocks for a try block
	there can be 0 or more catch blocks for a try block


Can we have try block without catch?


A try block must be followed by a catch or finally or both

try
{
}
finally
{}


try{}
catch{}



try{}
catch{}
finally{}


try{}
catch{}
catch{}
catch{}
finally{}


try{}
catch{}
catch{}
catch{}

Observations:
	try block alone is not possible
	catch should be below try block only
	finally comes only at the end. And only once.
	between try and catch and finally,  nothing else should be there

	
Activity:
	Identify few
		checked exceptions
		unchecked exceptions

Checked Exceptions:
	ClassNotFoundException
	NoSuchMethodException
	IOException
	FileNotFoundException
	SQLException
	ParseException

Unchecked Exceptions:
	ArrayIndexOutOfBoundsException
	ArithmeticException
	NullPointerException
	NumberFormatExeption
	IllegalArgumentException


Where to declare "throws"
and where to handle exceptions.

There are some classes, where we have methods that are meant to be called by other layers of the project
ex:
	DAO
	BO
	API

these classes contain lot of methods that are used by other layers
these are used by different type of front end applications

so the way you handle exception is different, so they are left to the calling methods
so in these library methods, we always throw exceptions and declare as throws and not handle.

Handling exceptions are mostly done at front end.
	main method (in case of java projects) is the front end



How to create our own exception classes?
	user defined exception class
A class that extends Exception class is user defined checked exception class
A class that extends RuntimeException class is user defined unchecked exception class

Try the exception problems uploaded now.


1) create an userdefined exception class
	skeleton already given 
		public class NotEligibleException extends Exception
		{		

			//we need to create the constructor
			public NotEligibleException(String message)
			{
				super(message);
			}
		}

2) whenever you throw an object of (user defined) exception (if that exception is a checked exception)
	declare the method with "throws clause"

3) When you handle the exception in catch block, getMessage()
			try{
				return CompanyJobRepository.getJobPrediction(age, highestQualification);
			}catch(NotEligibleException nee)
			{
				return nee.getMessage();
			}




Activity:
All of you start practice test for 
	Q1
	then
	Q3




group by

Mobiles
	company
	list of models


the output
	company	count
	samsung	10
	nokia	5
	redmi	12


<String, ArrayList<String>>

for(Entry<String,ArrayList<String>> entry:mobiles.entrySet)
{
	String company=entry.getKey();
	Integer count=entry.getValue().size();
}



SELECT
	order by

Collections.sort

