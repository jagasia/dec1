Plan for the day
--------------------
overriding equals method
Collections
String
Exception



We discussed about 
	==
	equals()

What is the difference between the above two?
	== compares references (when the operands are ref types)
	equals method compares the values

a and b are objects	(ref types)
a==b	checks if their references are same
a.equals	checks if their values are same

Integer
Float
Double

Employee
	id
	name
	salary

Employee e1=new Employee(1,"Raja",123456); 
Employee e2=new Employee(1,"Raja",123456);

e1==e2	
	what will be result?
		false

e1.equals(e2)
	clarify whether Employee class has overridden the equals method or not?



Hint:
	you can check if 2 dates are equal or not using equals method
		dt1.equals(dt2)

TasK:
	Java Mock 11 Req 1
		point #6	override the equals method

	Override the equals method and paste the method code alone in chat



What is the difference between
	nextLine()	use only newline delimiter
	next()	use any delimiter		space / tab / newline


while user enters input


india is our country

	the entire line is captured as a String (when you use nextLine())
	india is captured by next() method



Whenever you use nextLine method after a
	next() or
	nextInt() or
	nextFloat() or
	any other methods, you will face a problem





IIT Madras,www.iitm.ac.in,7845612390,iit,16,Madras,15-12-1959
	we can split this String into multiple Strings 
		



Integer.parseInt("12");		returns an int
Integer.valueOf("12");		returns an Integer



equalsIgnoreCase()	checks if both are equal, ignoring the case


TasK:
	accept a string input and parse it into an object
	check if those objects are equal or not

-----------------------------------------------------------
Collections
---------------
	how collections are different from arrays?
	1) Arrays are fixed length
	2) Size of arrays must be known when we create arrays
	
Collections in java, belongs to 
	java.util package

What are the collection classes we learn?

List	(interface)
	ArrayList		
	LinkedList		
Set
	HashSet
	TreeSet
	LinkedHashSet
Map
	HashMap
	TreeMap
	LinkedHashMap



Difference between List and Set?
1) List allows duplicates. Set does not allow duplicates		(Set is a collection of distinct objects)
2) List is ordered. Order is not asc or desc order. It is the order in which the elements are added.
	All lists are ordered.
	What about Set??????????		people say Set is unordered
		Every type of set has a particular order. (Need not be the order in which they are added)
		HashSet	- The order is based on hasCode() method
		TreeSet	- The order is sorted manner	based on Comparator / Comparable
		LinkedHashSet	-	Orderd	(similar to List)
3) List can be sorted (even after adding elements)
	Collections.sort(list);	
	Set does not allow us to re-arrange elements after added. 
	TreeSet maintains sorted order. But while adding elements, the elements are placed in correct locations while adding.
		later, rearranging is not possible
		you may convert the set into a list and sort it again
	
4) Traversing a list can be done from last to first is possible. 	Set do not have this.

list.add(10);
list.add(20);
list.add(10);
list.add(5);
list.add(30);

set.add(10);
set.add(20);
set.add(10);		//duplicate.		Rejected
set.add(5);
set.add(30);


What is the difference betwen Array and Collection?
	arrays can be primitives also
	int []arr=new int[10];	//possible
but, collections are always objects

	ArrayList<Integer> list=new ArrayList<>();	//possible
		remember ArrayList<int> is NOT possible






import java.util.ArrayList;

public class Main1 {

	public static void main(String[] args) {
		ArrayList<Integer> marks=new ArrayList<>();
		marks.add(90);
		marks.add(50);
		marks.add(40);
		marks.add(50);
		marks.add(80);
		marks.add(90);
		marks.add(100);
		marks.add(45);
		marks.add(76);
		
		System.out.println(marks);
	}

}

Output:
[90, 50, 40, 50, 80, 90, 100, 45, 76]


observation:
1) duplicates were allowed
2) order is same as added


import java.util.ArrayList;
import java.util.Iterator;

public class Main1 {

	public static void main(String[] args) {
		ArrayList<Integer> marks=new ArrayList<>();
		marks.add(90);
		marks.add(50);
		marks.add(40);
		marks.add(50);
		marks.add(80);
		marks.add(90);
		marks.add(100);
		marks.add(45);
		marks.add(76);
		
//		System.out.println(marks);
		
//		for(int i=0;i<marks.size();i++)
//		{
//			//Vector and ArrayList only have index
//			System.out.println(marks.get(i));
//		}
		
//		for(Integer x:marks)
//			System.out.println(x);
		
//		Iterator<Integer> it = marks.iterator();
//		while(it.hasNext())
//		{
//			Integer x = it.next();
//			System.out.println(x);
//		}
	}

}

Task:
------
	Create an arraylist of String type and 
	add few country names

	display all elements of array list using different methods



Problem:
	when i loop a collection
	and inside the loop, 
	if i remove an element of the collection,
	i face error
		ConcurrentModificationException


Iterator
	is used to traverse each element of a collection

	hasNext()		returns true when there is any more element to traverse
	next()		consumes an element and returns the same
	remove()		removes the current element



We used array list and now we can use LinkedList
	in LinkedList, we don't have index
		list.get(0)		//not possible
we can traverse a linked list using iterator or for each loop		(but not using for loop. because there is no index)

we can traverse a linked list in reverse order using
	ListIterator
		instead of iterator
		can work only for List (does not work for Set)
		
methods of ListIterator
	hasNext()
	next()
	remove()
	
	hasPrevious()
	previous()




public List<String> reverse(ArrayList<String> source)
{
	//reverse the source list and return
	ArrayList<String> result=new ArrayList<>();
	ListIterator<String> it=source.listIterator();
	while(it.hasNext())
	{
		it.next();
	}
	//reverse
	while(it.hasPrevious())
	{
		String s=it.previous();
		result.add(s);
	}
	return result;
}



--------------------------
TasK:
-------
	Java Mock 11 Req 2:
		createCollege method accepts csv and returns object of College
		split by ,
		addCollegeToUniversity
		removeCollege
		displayColleges



public University()
{
	this.collegeList=new ArrayList<>();	
}

public University(String name, List<College> collegeList)
{
	this.name=name;
	this.collegeList=collegeList;
}
https://github.com/jagasia/dec1/tree/jag2/java/mock-11/src

------------------------------------------
Once you have learned List
	ArrayList
	LinkedList

	legacy class	(synchronized)
		Vector
		Hashtable

Set
	Classes that implement the Set interface
		HashSet
		TreeSet
		LinkedHashSet

Set does not allow duplicates. Then what happens if we try to add duplicates?
	will it give error?	NO	
		No errors, but that attempt to add duplicate is rejected.



Whenever you create a HashSet of any type, that type class must override
	hashCode
	equals method

HashSet<Integer>
	Integer class already implements equals and override methods

	check
		ctrl+shift+code


Hashing
	allow us to search fast	
	while adding elements, they are added in particular location based on their hashCode
	later, to find elements, their hashCode is used to find fast

TasK:
	Java Mock 11
	Req #4

	practice task for ArrayList

----------------------------------------------
After HashSet
we learn TreeSet

What is significant about TreeSet?
---------------------------------------------
	A treeset maintains the elements in sorted manner



Collections.sort	reminder


Set


Tree



			55
TreeSet<Employee> empSet=new TreeSet<Employee>();
		empSet.add(new Employee(55, "Raja", 121212.0));
		empSet.add(new Employee(15, "Abdul", 621212.0));
		empSet.add(new Employee(51, "John", 141212.0));
		empSet.add(new Employee(155, "Zaheer", 521212.0));
		empSet.add(new Employee(515, "Brejesh", 921212.0));
		empSet.add(new Employee(551, "Dinesh", 21212.0));
		empSet.add(new Employee(255, "Prasad", 321212.0));
		empSet.add(new Employee(525, "Ram", 1221212.0));
		empSet.add(new Employee(525, "Gokul", 1321212.0));
		empSet.add(new Employee(55, "Manish", 421212.0));
		
		//we will get error when adding the first object to the treeset
		//because, Employee class is not comparable
		
		Solution:
			Employee class must implement Comparable



public class Employee implements Comparable<Employee>
{
	private Integer id;
	private String name;
	private Double salary;
	
	public Employee() {}

	public Employee(Integer id, String name, Double salary) {
		super();
		this.id = id;
		this.name = name;
		this.salary = salary;
	}

	public Integer getId() {
		return id;
	}

	public void setId(Integer id) {
		this.id = id;
	}

	public String getName() {
		return name;
	}

	public void setName(String name) {
		this.name = name;
	}

	public Double getSalary() {
		return salary;
	}

	public void setSalary(Double salary) {
		this.salary = salary;
	}

	@Override
	public String toString() {
		return "Employee [id=" + id + ", name=" + name + ", salary=" + salary + "]";
	}

	@Override
	public int compareTo(Employee arg0) {
//		return this.getId().compareTo(arg0.getId());
		return this.getId()-arg0.getId();
	}

	
}

-------------------------------------------------------------------------
Comparable
Comparator

Whenever, the entity class itself implements, then it implements Comparable interface
When we want an external comparator, then we use Comparator interface


Comparable
	public int compareTo

a.compareTo(b)
	a-b

-1		
0
+1

a=5
b=4

a-b	=1
b-a	=-1

when a and b are equal

a-b=0



equals		returns true/false
compareTo		returns -1 or 0 or 1



Collections.sort() method is used for sorting any list category collections. NOT FOR SET


In java 8, lambda is introduced

we can use lambda to implement functional interfaces

what is functional interface?
	an interface that has only 1 abstract method is a functional interface.

Comparator



import java.util.ArrayList;
import java.util.Collections;
import java.util.Comparator;


//class DescendingComparator implements Comparator<Integer>
//{
//
//	@Override
//	public int compare(Integer a, Integer b) {
//		return b-a;
//	}
//	
//}


public class Main4 {

	public static void main(String[] args) {
		ArrayList<Integer> marks=new ArrayList<Integer>();
		marks.add(90);
		marks.add(50);
		marks.add(70);
		marks.add(30);
		marks.add(40);
		marks.add(60);
		marks.add(95);
		marks.add(55);
		marks.add(65);
		marks.add(45);
		
		//sort the list
		//list can sorted. Set cannot be sorted after adding elements.
//		DescendingComparator dc=new DescendingComparator();
//		Collections.sort(marks,dc);

		Collections.sort(marks,(a,b)->b-a);
		
		System.out.println(marks);
	}

}



---------------------------------------------------------------
TasK:
	Java Mock 11 Req #5
		solve this problem using Comparable and Comparator
import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.Date;

public class College implements Comparable<College>
{
	private String name;
	private String website;
	private String mobile;
	private String founder;
	private Integer numberOfDept;
	private String location;
	private Date startingDate;
	
	public College() {}
	
	
	
	public College(String name, String website, String mobile, String founder, Integer numberOfDept, String location,
			Date startingDate) {
		super();
		this.name = name;
		this.website = website;
		this.mobile = mobile;
		this.founder = founder;
		this.numberOfDept = numberOfDept;
		this.location = location;
		this.startingDate = startingDate;
	}



	public String getName() {
		return name;
	}
	public void setName(String name) {
		this.name = name;
	}
	public String getWebsite() {
		return website;
	}
	public void setWebsite(String website) {
		this.website = website;
	}
	public String getMobile() {
		return mobile;
	}
	public void setMobile(String mobile) {
		this.mobile = mobile;
	}
	public String getFounder() {
		return founder;
	}
	public void setFounder(String founder) {
		this.founder = founder;
	}
	public Integer getNumberOfDept() {
		return numberOfDept;
	}
	public void setNumberOfDept(Integer numberOfDept) {
		this.numberOfDept = numberOfDept;
	}
	public String getLocation() {
		return location;
	}
	public void setLocation(String location) {
		this.location = location;
	}
	public Date getStartingDate() {
		return startingDate;
	}
	public void setStartingDate(Date startingDate) {
		this.startingDate = startingDate;
	}



	@Override
	public String toString() {
		SimpleDateFormat sdf=new SimpleDateFormat("dd-MM-yyyy");
		return String.format("%-15s %-20s %-15s %-15s %-20s %-15s %s\n", name,website,mobile,founder,numberOfDept,location,sdf.format(startingDate));
	}
	
	public static College createCollege(String detail)
	{
		SimpleDateFormat sdf=new SimpleDateFormat("dd-MM-yyyy");
		String[] arr = detail.split(",");
		College college=new College();
		college.setName(arr[0]);
		college.setWebsite(arr[1]);
		college.setMobile(arr[2]);
		college.setFounder(arr[3]);
		college.setNumberOfDept(Integer.parseInt(arr[4]));
		college.setLocation(arr[5]);
		try {
			college.setStartingDate(sdf.parse(arr[6]));
		} catch (ParseException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		return college;
	}

	@Override
	public int compareTo(College o) {	
		return this.getName().compareTo(o.getName());
	}
	
	
}


-----------------------------------
import java.util.Comparator;

public class StartingDateComparator implements Comparator<College>
{

	@Override
	public int compare(College a, College b) {
		return a.getStartingDate().compareTo(b.getStartingDate());
	}

}

-------------------------------------
import java.util.Comparator;

public class DepartmentComparator implements Comparator<College>{

	@Override
	public int compare(College o1, College o2) {
		return o1.getNumberOfDept().compareTo(o2.getNumberOfDept());
	}

}


--------------------------------------
import java.util.ArrayList;
import java.util.Collections;
import java.util.Scanner;

public class Main {

	public static void main(String[] args) {
		Scanner sc=new Scanner(System.in);
		ArrayList<College> collegeList=new ArrayList<College>();
		System.out.println("Enter the number of the colleges:");
		int noOfColleges=sc.nextInt();
		for(int i=0;i<noOfColleges;i++)
		{
			String detail=sc.nextLine();
			if(detail.equals(""))
				detail=sc.nextLine();
			College college=College.createCollege(detail);
			collegeList.add(college);
		}
		
		System.out.println("Enter a type to sort:\r\n" + 
				"1.Sort by name\r\n" + 
				"2.Sort by number of departments\r\n" + 
				"3.Sort by starting date\r\n" + 
				"");
		
		int choice=sc.nextInt();
		switch(choice)
		{
		case 1:			//name
			Collections.sort(collegeList);
			break;
		case 2:			//number  of dept
			Collections.sort(collegeList,new DepartmentComparator());
			break;
		case 3:			//starting date
			Collections.sort(collegeList,new StartingDateComparator());
			break;
		default:
			break;
		}
		
		System.out.format("%-15s %-20s %-15s %-15s %-20s %-15s %s\n", "Name","Website","Mobile","Founder","No of departments","Location","Starting date");
		for(College c:collegeList)
			System.out.print(c);
	}

}

----------------------
TasK:
	Java_Mock_29_NoPrefill	Req # 5
	use Comparable and Comparator to solve this requirement.

